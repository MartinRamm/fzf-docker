#!/bin/bash

# $1 (Optionally) - if present (value doesn't matter), this test checks if any containers exist. Else, if active (running) containers exis
__docker_pre_test() {
  if [[ -z "$1" ]] && [[ $(docker ps --format '{{.Names}}') ]]; then
    return 0;
  fi

  if [[ ! -z "$1" ]] && [[ $(docker ps -a --format '{{.Names}}') ]]; then
    return 0;
  fi

  echo "No containers found";
  return 1;
}

__docker_images_pre_test() {
  if [[ $(docker images -qa) ]]; then
    return 0;
  fi
  echo "No images found"
  return 1;
}

#1 (Optional) path to `docker-compose.yml` file
__docker_compose_pre_test() {
  if [ -z "$1" ]; then
    if [[ $(docker-compose config --services) ]]; then
      return 0;
    fi
    echo "No docker-compose.yml found (or it contains errors). You can pass as the first argument a path to the service declaration file."
    return 1;
  fi

  if [[ $(docker-compose --file $1 config --services) ]]; then
    return 0;
  fi
  echo "Invalid service declaration file $1."
  return 1;
}

# $1: time interval - e.g.: `1m` for 1 minute
# $2: names of container(s) to display logs from
__docker_logs() (
  local since=""
  if [ ! -z "$1" ]; then
    since="--since $1 "
  fi

  local count=$(wc -l <<< $2)
  if [[ -z "$2" ]]; then
    return 1
  fi
  if [[ "$count" -eq "1" ]]; then
    eval "docker logs -f $since$2"
    return 0
  fi

  local resetColor="\033[39m\033[49m"
  #list of 48 distinct colors
  local allColors="\033[90m\n\033[92m\n\033[93m\n\033[94m\n\033[95m\n\033[96m\n\033[97m\n\033[30m\n\033[31m\n\033[32m\n\033[33m\n\033[34m\n\033[35m\n\033[36m\n\033[40m\033[90m\n\033[40m\033[91m\n\033[40m\033[92m\n\033[40m\033[94m\n\033[40m\033[95m\n\033[40m\033[96m\n\033[40m\033[97m\n\033[41m\033[90m\n\033[41m\033[93m\n\033[41m\033[95m\n\033[41m\033[97m\n\033[42m\033[90m\n\033[42m\033[93m\n\033[42m\033[97m\n\033[43m\033[90m\n\033[43m\033[93m\n\033[43m\033[97m\n\033[44m\033[91m\n\033[44m\033[92m\n\033[44m\033[93m\n\033[44m\033[95m\n\033[44m\033[97m\n\033[45m\033[93m\n\033[45m\033[97m\n\033[46m\033[90m\n\033[46m\033[91m\n\033[46m\033[92m\n\033[46m\033[93m\n\033[46m\033[96m\n\033[46m\033[97m\n\033[47m\033[90m\n\033[47m\033[95m\n\033[47m\033[96m\n"
  #list of `$count` number of distinct colors
  local colors=$(echo $allColors | shuf -n $count)
  echo "$2" \
    | while read -r name; do
        #last color from list
        local color=$(echo $colors | tail -n 1)
        #update list - remove last color from list
        colors=$(echo $colors | head -n -1)

        eval "docker logs -f $since\"$name\" |& sed -e \"s/^/`printf \"${color}[$name]${resetColor}\"` /\" &"
      done

  function _exit {
    while read -r name; do
      pkill -f "docker logs -f $since$name"
    done <<< "$2"
  }

  trap _exit INT TERM

  wait
)

__docker_compose_fileref_generator() {
  if [ ! -z "$1" ]; then
    echo "--file $1"
  fi
}

#1 (Optional) path to `docker-compose.yml` file
#2 A regexp that needs to be present in the docker-compose.yml file for this command to return it
__docker_compose_parse_services_config() {
  local fileref=$(__docker_compose_fileref_generator $1)

  # `docker-compose config` normalizes the indentation and format, no matter what the actual file is...
  local config=$(eval "docker-compose $fileref config")

  local inServicesBlock='false'
  local service=''

  echo -e "$config" \
    | while IFS= read -r line; do
        if [[ "$line" == "services:" ]]; then
          inServicesBlock='true'
        elif [[ "$line" =~ ^[^:" "]+:.*$ ]]; then
          inServicesBlock='false'
        fi

        if [[ "$inServicesBlock" == "true" ]]; then
          if [[ "$line" =~ ^" "{2}[^:" "]+:$ ]]; then
            local service=$(echo -e "$line" | grep -o '[^: ]\+')
          fi

          if [[ "$line" =~ $2 ]] && [[ ! -z "service" ]]; then
            echo "$service"
            service=''
          fi
        fi
      done
}

#docker restart
dr() {
  __docker_pre_test
  if [ $? -eq 0 ]; then
    local containers=$(docker ps --format '{{.Names}}' | fzf -m)

    echo -e "$containers" \
      | while read -r name; do
          echo "Restarting $name..."
          docker restart $name
        done

    __docker_logs "1m" "$containers"
  fi
}

#docker logs
dl() {
  __docker_pre_test "all"
  if [ $? -eq 0 ]; then
    local containers=$(docker ps -a --format '{{.Names}}' | fzf -m)
    __docker_logs "$1" "$containers"
  fi
}

#docker logs all
dla() {
  __docker_pre_test "all"
  if [ $? -eq 0 ]; then
    local containers=$(docker ps -a --format '{{.Names}}')
    __docker_logs "$1" "$containers"
  fi
}

#docker exec
de() {
  __docker_pre_test
  if [ $? -eq 0 ]; then
    local name=$(docker ps --format '{{.Names}}' | fzf)

    if [ ! -z "$name" ]; then
      local command="$1"

      if [ -z "$command" ] && [ -f "$HOME/.docker-fuzzy-search-exec" ]; then
        command=$($HOME/.docker-fuzzy-search-exec "$name")
      fi

      if [ -z "$command" ]; then
        local imageName=$(docker inspect --format '{{.Config.Image}}' $name | sed -e 's/:.*$//g') #without version
        case "$imageName" in
          "mysql" | "bitnami/mysql" | "mysql/mysql-server" | "percona" | centos/mysql*)
            command='mysql -uroot -p$MYSQL_ROOT_PASSWORD'
          ;;

          "mongo" | "circleci/mongo")
            command='if [ -z "$MONGO_INITDB_ROOT_USERNAME" ]; then mongo; else mongo -u "$MONGO_INITDB_ROOT_USERNAME" -p "$MONGO_INITDB_ROOT_PASSWORD"; fi'
          ;;
          "bitnami/mongodb")
            command='if [ -z "$MONGODB_USERNAME" ]; then mongo; else mongo -u "$MONGODB_USERNAME" -p "$MONGODB_PASSWORD" "$MONGODB_DATABASE"; fi'
          ;;
          centos/mongodb*)
            command='mongo -u "admin" -p "$MONGODB_ADMIN_PASSWORD" --authenticationDatabase admin'
          ;;

          "redis" | "circleci/redis" | "bitnami/redis" | centos/redis*)
            command='echo -n "Enter DB Number to connect to (^[1-9][0-9]?$): " && read dbNum && redis-cli -n $dbNum'
            if [[ "$imageName" == "bitnami/redis" ]] || [[ "$imageName" == "centos/redis"* ]]; then
              command="if [ -z \$REDIS_PASSWORD ]; then $command; else $command -a \"\$REDIS_PASSWORD\"; fi"
            fi
          ;;

          *)
            command='sh'
            command=" ash; if [ \"\$?\" -eq \"127\" ]; then $command; fi"
            command="bash; if [ \"\$?\" -eq \"127\" ]; then $command; fi"
            command=" zsh; if [ \"\$?\" -eq \"127\" ]; then $command; fi"
        esac

        command="sh -c '$command'"
      fi

      eval "docker exec -it $name $command"
    fi
  fi
}

#docker remove
drm() {
  __docker_pre_test "all" \
    && docker ps -aq --format "{{.Names}}" \
      | fzf -m \
      | while read -r name; do
          docker rm -f $name
        done
}

#docker remove all
drma() {
  __docker_pre_test "all" \
    && docker rm $(docker ps -aq) -f
}

#docker stop
ds() {
  __docker_pre_test \
    && docker ps --format '{{.Names}}' \
      | fzf -m  \
      | while read -r name; do
          docker update --restart=no $name
          docker stop $name
        done
}

#docker stop all
dsa() {
  __docker_pre_test
  if [ $? -eq 0 ]; then
    docker update --restart=no $(docker ps -q)
    docker stop $(docker ps -q)
  fi
}

#docker stop
dsrm() {
  __docker_pre_test \
    && docker ps --format '{{.Names}}' \
      | fzf -m  \
      | while read -r name; do
          docker update --restart=no $name
          docker stop $name
          docker rm -f $name
        done
}

#docker stop all
dsrma() {
  dsa

  drma
}

#docker kill
dk() {
  __docker_pre_test \
    && docker ps --format '{{.Names}}' | fzf -m --print0 \
      | fzf -m \
      | while read -r name; do
          docker update --restart=no $name
          docker kill $name
        done
}

#docker kill
dka() {
  __docker_pre_test
  if [ $? -eq 0 ]; then
    docker update --restart=no $(docker ps -q)
    docker kill $(docker ps -q)
  fi
}

#docker kill
dkrm() {
  __docker_pre_test \
    && docker ps --format '{{.Names}}' \
      | fzf -m \
      | while read -r name; do
          docker update --restart=no $name
          docker kill $name
          docker rm -f $name
        done
}

#docker kill
dkrma() {
  dka

  drma
}

#docker remove image
drmi() {
  __docker_images_pre_test \
    && docker images --format "{{.Repository}}:{{.Tag}}" --filter "dangling=false" \
      | fzf -m \
      | while read -r ref; do
          local id=$(docker images --filter "reference=$ref" --format "{{.ID}}")
          docker rmi $id -f
        done
}

#docker remove all images
drmia() {
  __docker_images_pre_test \
    && docker rmi $(docker images -qa) -f
}

#docker clean
dclean() {
  dsrma
  drmia
}

#docker compose up
dcu() {
  local fileref=$(__docker_compose_fileref_generator $1)

  __docker_compose_pre_test $1 \
      && eval "docker-compose $fileref config --services" \
        | fzf -m \
        | while read -r service; do
            eval "docker-compose $fileref up -d $service"
          done
}

#docker compose up all
dcua() {
  local fileref=$(__docker_compose_fileref_generator $1)

  __docker_compose_pre_test $1 \
    && eval "docker-compose $fileref up -d"
}

#docker compose build
dcb() {
  local fileref=$(__docker_compose_fileref_generator $1)

  __docker_compose_pre_test $1 \
    && __docker_compose_parse_services_config "$1" '^    build:.*$' \
      | fzf -m \
      | while read -r service; do
          eval "docker-compose $fileref build --force-rm --no-cache --pull $service"
        done
}

#docker compose build all
dcba() {
  local fileref=$(__docker_compose_fileref_generator $1)

  __docker_compose_pre_test $1 \
    && eval "docker-compose $fileref build --force-rm --no-cache --pull --parallel"
}

#docker compose pull
dcp() {
  local fileref=$(__docker_compose_fileref_generator $1)

  __docker_compose_pre_test $1 \
    && __docker_compose_parse_services_config "$1" '^    image:.*$' \
      | fzf -m \
      | while read -r service; do
          eval "docker-compose $fileref pull --ignore-pull-failures $service"
        done
}

#docker compose pull all
dcpa() {
  local fileref=$(__docker_compose_fileref_generator $1)

  __docker_compose_pre_test $1 \
    && eval "docker-compose $fileref pull --ignore-pull-failures"
}

#docker compose update image
dcupd() {
  local fileref=$(__docker_compose_fileref_generator $1)

  __docker_compose_pre_test $1
  if [ "$?" -eq "0" ]; then
    local buildServices=$(__docker_compose_parse_services_config "$1" '^    build:.*$')
    local pullServices=$(__docker_compose_parse_services_config "$1" '^    image:.*$')

    eval "docker-compose $fileref config --services" \
      | fzf -m \
      | while read -r service; do
          echo -e "$buildServices" \
            | while read -r buildService; do
                if [[ "$buildService" == "$service" ]]; then
                  eval "docker-compose $fileref build --force-rm --no-cache --pull $service"
                  continue 2;
                fi
              done

          echo -e "$pullServices" \
            | while read -r pullService; do
                if [[ "$pullService" == "$service" ]]; then
                  eval "docker-compose $fileref pull --ignore-pull-failures $service"
                  continue 2;
                fi
              done
        done
  fi
}

#docker compose update image all services
dcupda() {
  dcba "$1"

  dcpa "$1"
}

fzf-docker-debug-info() {
  location="${BASH_SOURCE[0]}"
  if [ -z "$location" ]; then #fzf
    location=$(type -a $0 | sed "s/$0 is a shell function from //g")
  fi;
  gitRepo="$(dirname $location)/.git"
  commitHash=$(eval "git --git-dir $gitRepo rev-parse HEAD")
  latestTag=$(eval "git --git-dir $gitRepo describe --tags")
  fzfDockerVersion="$latestTag ($commitHash)"

  shellEnvironment=$(ps p "$$" o cmd=)

  shell=$(echo $shellEnvironment | grep -oE "^\S+")
  shellVersion=$(eval "$shell --version")
  fzfVersion=$(fzf --version)

  dockerVersion=$(docker --version)
  dockerComposeVersion=$(docker-compose --version)

  dockerExecCustomDefaults=$(test -f "$HOME/.docker-fuzzy-search-exec" && cat "$HOME/.docker-fuzzy-search-exec" || echo "N.A.")

  for v in "fzfDockerVersion" "shellEnvironment" "shellVersion" "fzfVersion" "dockerVersion" "dockerComposeVersion" "dockerExecCustomDefaults"; do
    echo -e "${v}:"
    v=$(eval "echo -e \"\$$v\"" | sed 's/^/\t/g')
    echo -e "$v"
  done;
}
